import{_ as p,c as i,a as t,e as u,k as b,g as C,t as n,v as h,x as v,f,i as g,n as x,y,o as c}from"./index-CpEXMNlz.js";import{M as A}from"./MenuCarro-DkDZxGqw.js";import{b as E}from"./evaluation-lVSGxhip.js";const z={components:{MenuCarro:A},props:{msg:String},setup(){return{evaluacionAbstractionStore:E()}},data(){return{attempts:0,maxAttempts:3,evaluacion:null,isCorrect:!1,code:"",result:"",resultClass:"",correctCode:`#include <stdio.h>
#include <string.h>

char* ConectarCables(char cable1[], char cable2[]) {
if ((!strcmp(cable1, "rojo") && !strcmp(cable2, "negro")) ||
(!strcmp(cable1, "negro") && !strcmp(cable2, "rojo"))) {
printf("Cable rojo y negro conectados.");
} else {
printf("Error: No se han enviado los cables correctos.");
}
}

int main() {

char cableA[] = "rojo";
char cableB[] = "negro";

printf("%s\\n", ConectarCables(cableA, cableB));

return 0;
}`}},computed:{isRetryDisabled(){return this.isCorrect||this.attempts>=this.maxAttempts},isFinishEnabled(){return this.isCorrect||this.attempts>=this.maxAttempts}},methods:{analyzeCode(){if(this.isCorrect===!0||this.attempts>=this.maxAttempts)return;this.attempts++;const d=this.code.replace(/\s+/g," ").trim(),e=this.correctCode.replace(/\s+/g," ").trim();let l="";d!==e&&(l="El código ingresado no coincide con la solución esperada. Revisa la sintaxis, espacios y elimine cualquier comentario que haya: "),y.post("http://localhost:5000/api/auth/analyze",{code:this.code}).then(r=>{let s="";r.data.errors&&(s=r.data.errors),l||s?(this.result=[l,s].filter(Boolean).join(`
`),this.resultClass="warning"):(this.result="¡El código es correcto!",this.resultClass="success",this.isCorrect=!0),this.calcularEvaluacion()}).catch(r=>{console.error("Error al analizar el código:",r),this.result="Ha ocurrido un error al analizar el código. Inténtalo nuevamente.",this.resultClass="warning"}),this.calcularEvaluacion()},calcularEvaluacion(){this.isCorrect===!0?this.attempts===1?this.evaluacion=5:this.attempts===2?this.evaluacion=4:this.attempts===3&&(this.evaluacion=3):this.attempts===this.maxAttempts&&(this.evaluacion=1)},finish(){this.evaluacionAbstractionStore.evaluacion=this.evaluacion,x.push("/GeneralizacionConectarCables").then(()=>{window.scrollTo(0,0)})}}},j={id:"user"},k={class:"card card-body mt-8, align-left, col-md-15"},S={class:"hello"},B=["disabled"],w={key:0,class:"contador"},M={key:0,class:"correcto alert alert-success mt-3"},N=["disabled"],V={class:"alert alert-primary"},q={class:"align-left col-md-3"},D={class:"temas"};function T(d,e,l,r,s,o){const m=g("MenuCarro");return c(),i("div",j,[t("div",k,[e[8]||(e[8]=t("h1",{class:"text-center"},"Paso 1. Conectar cables a los motorreductores",-1)),e[9]||(e[9]=t("br",null,null,-1)),e[10]||(e[10]=t("h3",null,"Ejercicio:",-1)),e[11]||(e[11]=t("br",null,null,-1)),e[12]||(e[12]=t("p",{class:"texto-personalizado"},' Se necesita un programa en C que simule la conexión de dos cables uno rojo y otro negro a un motoreductor. Cuando se haga la conexión imrpimir el mensaje: "cable rojo y negro conectados". ',-1)),e[13]||(e[13]=t("p",{class:"texto-personalizado"},[t("strong",null,"Instrucciones:"),b(" Los cables deben ser variables del tipo cadena de caracter. La conexión debe ser una función del tipo cadena de caracter, la cual debe imprimir el mensaje. ")],-1)),e[14]||(e[14]=t("br",null,null,-1)),e[15]||(e[15]=t("h3",null,"Abstracción:",-1)),e[16]||(e[16]=t("br",null,null,-1)),t("div",S,[t("h1",null,n(l.msg),1),C(t("textarea",{"onUpdate:modelValue":e[0]||(e[0]=a=>s.code=a),placeholder:"Escribe tu código aquí"},null,512),[[h,s.code]]),e[3]||(e[3]=t("br",null,null,-1)),e[4]||(e[4]=t("br",null,null,-1)),t("button",{onClick:e[1]||(e[1]=(...a)=>o.analyzeCode&&o.analyzeCode(...a)),disabled:o.isRetryDisabled}," Analizar Código ",8,B),e[5]||(e[5]=t("br",null,null,-1)),e[6]||(e[6]=t("br",null,null,-1)),s.attempts>0&&!s.isCorrect?(c(),i("p",w," intentos restantes: "+n(s.maxAttempts-s.attempts),1)):u("",!0),e[7]||(e[7]=t("br",null,null,-1)),s.result?(c(),i("p",{key:1,class:v(s.resultClass)},n(s.result),3)):u("",!0)]),e[17]||(e[17]=t("br",null,null,-1)),s.isCorrect||s.attempts>=s.maxAttempts?(c(),i("p",M," Tu evaluación final es: "+n(s.evaluacion),1)):u("",!0),t("div",null,[s.isCorrect||s.attempts===s.maxAttempts?(c(),i("button",{key:0,class:"bt-validate",disabled:!o.isFinishEnabled,onClick:e[2]||(e[2]=(...a)=>o.finish&&o.finish(...a))}," Avanzar ",8,N)):u("",!0)]),t("p",V," Evaluación Abstracción: "+n(r.evaluacionAbstractionStore.evaluacion.toFixed(1)),1)]),t("div",q,[t("div",D,[f(m)])])])}const L=p(z,[["render",T]]);export{L as default};
